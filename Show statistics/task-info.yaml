type: edu
files:
- name: resources/application.properties
  visible: true
  text: |
    server.port=28852
    management.endpoints.web.exposure.include=*
    management.endpoint.shutdown.enabled=true
  learner_created: false
- name: src/rest/Main.java
  visible: true
  text: |
    package rest;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication
    public class Main {
        public static void main(String[] args) {
            SpringApplication.run(Main.class, args);
        }
    }
  learner_created: false
- name: build.gradle
  visible: true
  text: |-
    buildscript {
        apply plugin: 'hyperskill'

        repositories {
            mavenCentral()
        }

        dependencies {
            classpath "org.springframework.boot:spring-boot-gradle-plugin:$hs.spring.bootVersion"
            classpath "io.spring.gradle:dependency-management-plugin:$hs.spring.dependencyManagementVersion"
        }
    }

    apply plugin: 'java'
    apply plugin: 'org.springframework.boot'
    apply plugin: 'io.spring.dependency-management'

    repositories {
        mavenCentral()
    }

    sourceSets.main.resources.srcDirs = ["resources"]

    dependencies {
        implementation 'org.springframework.boot:spring-boot-starter'
        implementation 'org.springframework.boot:spring-boot-starter-jdbc'
        implementation 'org.springframework.boot:spring-boot-starter-actuator'
        implementation 'org.springframework.boot:spring-boot-starter-web'
        runtimeOnly 'com.h2database:h2'
        implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
        implementation 'org.springframework.boot:spring-boot-starter-validation'

        implementation 'com.fasterxml.jackson.core:jackson-core:2.10.1'
        implementation 'com.fasterxml.jackson.core:jackson-annotations:2.10.1'
        implementation 'com.fasterxml.jackson.core:jackson-databind:2.10.1'
    }
  learner_created: false
- name: test/AppointmentBookingToDoctorRestServiceTest.java
  visible: false
  text: |
    import com.fasterxml.jackson.annotation.JsonInclude;
    import com.fasterxml.jackson.core.JsonProcessingException;
    import com.fasterxml.jackson.databind.ObjectMapper;
    import com.google.gson.*;
    import com.google.gson.reflect.TypeToken;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.dynamic.input.DynamicTesting;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.mocks.web.response.HttpResponse;
    import org.hyperskill.hstest.stage.SpringTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.junit.Before;

    import java.io.File;
    import java.lang.reflect.Type;
    import java.time.LocalDate;
    import java.time.format.DateTimeFormatter;
    import java.util.*;
    import java.util.stream.Collectors;

    import static org.hyperskill.hstest.common.JsonUtils.getJson;
    import static org.hyperskill.hstest.testing.expect.Expectation.expect;
    import static org.hyperskill.hstest.testing.expect.json.JsonChecker.isNumber;
    import static org.hyperskill.hstest.testing.expect.json.JsonChecker.isObject;


    class RequestForTest {


        private Map<String, Object> properties = new LinkedHashMap<>();

        public RequestForTest(RequestForTest another) {
            this.properties = another.properties.entrySet().stream()
                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
        }

        public RequestForTest() {
        }

        public String toJson() {
            ObjectMapper mapper = new ObjectMapper();
            mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
            try {
                return mapper.writeValueAsString(this.properties);
            } catch (JsonProcessingException e) {
                System.out.println(e.getMessage());
                return null;
            }

        }


        public RequestForTest setProps(String key, Object value) {
            properties.put(key, value);
            return this;
        }

    }

    public class AppointmentBookingToDoctorRestServiceTest extends SpringTest {

        private static final String databaseFileName = "\\AppointToDoctorRestService\\AppointToDoctorRestService\\d.mv.db";

        public String toJsonStatistics(Map<String, Integer> map) {
            ObjectMapper mapper = new ObjectMapper();
            mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
            try {
                return mapper.writeValueAsString(map);
            } catch (JsonProcessingException e) {
                System.out.println(e.getMessage());
                return null;
            }

        }

        private String convert(String[] trs) {
            JsonArray jsonArray = new JsonArray();
            for (String tr : trs) {
                JsonElement jsonObject = JsonParser.parseString(tr);
                jsonArray.add(jsonObject);
            }
            return jsonArray.toString();
        }

        //quantity of available days for appointment for each doctor
        private final int availableDays = 4;

        //Endpoints list
        private final String setAppointment = "/setAppointment";
        private final String appointments = "/appointments";
        private final String deleteAppointment = "/deleteAppointment?id=";
        private final String newDoctor = "/newDoctor";
        private final String availbleDates = "/availableDatesByDoctor?doc=";

        private final String deleteDoctor = "/deleteDoctor?doc=";
        private final String statisticsDoctor = "/statisticsDoc";
        private final String statisticsDay = "/statisticsDay";

        // Doctors' names
        private final String director = "director";
        private final String phillGood = "Phill good";
        private final String leaWong = "Lea Wong";
        private final String pamelaUpperson = "Pamela Upperson";
        private final String doctorHouse = "Dr. House";
        private final String unknownDoctor = "Unknown";

        //List and maps for corrent information storage about doctors, appointments, available days, statistics
        List<Long> ids = new ArrayList<>();
        List<Long> idsForAppointments = new ArrayList<>();
        Map<String, JsonArray> mapOfAvailableDaysByDoctor = new TreeMap<>();
        Map<String, Integer> statisticsPerDoctor = new TreeMap<>();
        Map<String, Integer> statisticsPerDay = new TreeMap<>();
        List<String> appointmentsCorrectJson = new ArrayList<>();
        List<String> doctorsList = new ArrayList<>();
        List<Long> doctorsIdList = new ArrayList<>();


        LocalDate date = LocalDate.now();
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");

        private final String directorApp1 = new RequestForTest().setProps("doctor", director)
                .setProps("patient", "Bol it")
                .setProps("date", dateTimeFormatter.format(date)).toJson();

        private final String leaWongApp1 = new RequestForTest().setProps("doctor", leaWong)
                .setProps("patient", "Ay Bolit")
                .setProps("date", dateTimeFormatter.format(date.plusDays(1))).toJson();

        private final String pamelaUppersonApp1 = new RequestForTest().setProps("doctor", "Pamela Upperson")
                .setProps("patient", "John Galt")
                .setProps("date", dateTimeFormatter.format(date.plusDays(1))).toJson();

        private final String leaWongApp2 = new RequestForTest().setProps("doctor", "Lea Wong")
                .setProps("patient", "Indi Grimes")
                .setProps("date", dateTimeFormatter.format(date.plusDays(2))).toJson();

        private final String leaWongApp3 = new RequestForTest().setProps("doctor", "Lea Wong")
                .setProps("patient", "Indi Grimes")
                .setProps("date", dateTimeFormatter.format(date.plusDays(3))).toJson();

        private final String leaWongApp4 = new RequestForTest().setProps("doctor", "Lea Wong")
                .setProps("patient", "Indi Grimes")
                .setProps("date", dateTimeFormatter.format(date.plusDays(4))).toJson();

        private final String pamelaUppersonApp2 = new RequestForTest().setProps("doctor", "Pamela Upperson")
                .setProps("patient", "Ay")
                .setProps("date", dateTimeFormatter.format(date.plusDays(2))).toJson();

        private final String pamelaUppersonApp3 = new RequestForTest().setProps("doctor", "Pamela Upperson")
                .setProps("patient", "Ay")
                .setProps("date", dateTimeFormatter.format(date.plusDays(3))).toJson();

        private final String pamelaUppersonApp4 = new RequestForTest().setProps("doctor", "Pamela Upperson")
                .setProps("patient", "Ay")
                .setProps("date", dateTimeFormatter.format(date.plusDays(4))).toJson();

        private final String drHouse = new RequestForTest().setProps("doctor", doctorHouse)
                .setProps("patient", "Ay")
                .setProps("date", dateTimeFormatter.format(date.plusDays(4))).toJson();

        private final RequestForTest newDocLeaWong = new RequestForTest().setProps("doctor", leaWong)
                .setProps("patient", "Bol it")
                .setProps("date", dateTimeFormatter.format(date.plusDays(4)));

        private final String doctorNameEmpty = new RequestForTest(newDocLeaWong).setProps("doctor", "").toJson();
        private final String doctorNameSpaces = new RequestForTest(newDocLeaWong).setProps("doctor", "   ").toJson();
        private final String noPatientName = new RequestForTest(newDocLeaWong).setProps("patient", null).toJson();
        private final String patientNameEmpty = new RequestForTest(newDocLeaWong).setProps("patient", "").toJson();
        private final String patientSpaces = new RequestForTest(newDocLeaWong).setProps("patient", "      ").toJson();
        private final String noDoctorName = new RequestForTest(newDocLeaWong).setProps("doctor", null).toJson();
        private final String dateEmpty = new RequestForTest(newDocLeaWong).setProps("date", "").toJson();
        private final String noDate = new RequestForTest(newDocLeaWong).setProps("date", null).toJson();
        private final String wrongDateFormat = new RequestForTest(newDocLeaWong).setProps("date", "2021-10-11 22:00").toJson();


        private final String docDirector = new RequestForTest().setProps("doctorName", director).toJson();
        private final String doctorPhilGood = new RequestForTest().setProps("doctorName", phillGood).toJson();
        private final String doctorLeaWong = new RequestForTest().setProps("doctorName", leaWong).toJson();
        private final String doctorPamelaUpperson = new RequestForTest().setProps("doctorName", pamelaUpperson).toJson();
        private final String doctorDrHouse = new RequestForTest().setProps("doctorName", doctorHouse).toJson();
        private final String doctorAddEmptyName = new RequestForTest().setProps("doctorName", "").toJson();
        private final String doctorAddNull = new RequestForTest().toJson();
        private final String doctorAddEmptySpaces = new RequestForTest().setProps("doctorName", "         ").toJson();

        CheckResult testPostApi(String api, String body, int status, String message) {
            HttpResponse response = post(api, body).send();
            if (response.getStatusCode() != status) {
                return CheckResult.wrong("POST " + api + " should respond with "
                        + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                        + message + "\n"
                        + "Response body:\n" + response.getContent() + "\n"
                        + "Request body:\n" + body);
            }
            return CheckResult.correct();
        }

        CheckResult testGetApi(String api, int status, String message) {
            HttpResponse response = get(api).send();
            if (response.getStatusCode() != status) {
                return CheckResult.wrong("GET " + api + " should respond with "
                        + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                        + message + "\n"
                        + "Response body:\n" + response.getContent() + "\n"
                );
            }
            System.out.println(response.getContent());
            return CheckResult.correct();
        }

        @DynamicTest(order = -1)
        DynamicTesting[] dt = new DynamicTesting[]{

                // negative tests
                () -> testGetApi(availbleDates + leaWong.trim().replaceAll("[\\s]+", "%20"), 204, "Wrong Status code"),
                () -> testGetApi(appointments, 204, "Wrong Status code"),
                () -> testPostApi(newDoctor, doctorAddEmptyName, 400, "Empty doctorName field!"),
                () -> testPostApi(newDoctor, doctorAddNull, 400, "doctorName field is absent!"),
                () -> testPostApi(newDoctor, doctorAddEmptySpaces, 400, "doctorName field is absent!"),//#5

                // negative tests
                () -> testPostApi(setAppointment, doctorNameEmpty, 400, "Empty doctorName field!"),
                () -> testPostApi(setAppointment, noDoctorName, 400, "doctorName field is absent!"),
                () -> testPostApi(setAppointment, doctorNameSpaces, 400, "doctorName field is absent!"),
                () -> testGetApi(availbleDates + unknownDoctor.trim().replaceAll("[\\s]+", "%20"), 204, "should answer status 204 - no available time for unknown doctor "),

                // negative tests


                () -> testGetApi(appointments, 204, "Wrong Status code"),//#10
                () -> testGetApi(statisticsDoctor, 204, "Wrong Status code"),
                () -> testGetApi(statisticsDay, 204, "Wrong Status code"),

                () -> testPostApi(setAppointment, wrongDateFormat, 400, "wrong date format!"),

                //positive check of Doctors endpoints
                () -> testAvailableDatesByDoctor(leaWong, availableDays, 204),//#14
                () -> newDoctorEndpointCheck(doctorLeaWong),//#15
                () -> testPostApi(newDoctor, doctorLeaWong, 400, "Should not add new doctor with the same name"),
                () -> testAvailableDatesByDoctor(leaWong, availableDays, 200), //#17
                () -> getAllDoctorslist(),//#18

                () -> testPostApi(setAppointment, patientNameEmpty, 400, "Empty patientName field!"),//#19
                () -> testPostApi(setAppointment, noPatientName, 400, "patientName field is absent!"),
                () -> testPostApi(setAppointment, patientSpaces, 400, "patientName field is absent!"),

                () -> testPostApi(setAppointment, dateEmpty, 400, "Empty date field!"),
                () -> testPostApi(setAppointment, noDate, 400, "date field is absent!"),

                () -> testDeleteDoctor(deleteDoctor, leaWong, 200, "should delete doctor"),

                this::reloadServer,
                () -> getAllDoctorslist(),//#25

                () -> testAvailableDatesByDoctor("director", availableDays, 200),//#26
                () -> testAvailableDatesByDoctor(leaWong, availableDays, 204),//#27
                () -> newDoctorEndpointCheck(doctorLeaWong),//#28
                () -> testAvailableDatesByDoctor(leaWong, availableDays, 200),//#29
                () -> newDoctorEndpointCheck(doctorPamelaUpperson),//#30
                () -> testPostApi(newDoctor, doctorPamelaUpperson, 400, "Should not add new doctor with the same name"),
                () -> testDeleteDoctor(deleteDoctor, pamelaUpperson, 200, "should delete doctor"),//#30
                () -> getAllDoctorslist(), //#33
                () -> newDoctorEndpointCheck(doctorPamelaUpperson),//#34

                () -> newDoctorEndpointCheck(doctorPhilGood),//#35
                () -> getAllDoctorslist(), //#36
                () -> testDeleteDoctor(deleteDoctor, phillGood, 200, "should delete doctor"),
                () -> testPostApi(newDoctor, doctorPamelaUpperson, 400, "Should not add new doctor with the same name"),
                () -> newDoctorEndpointCheck(doctorDrHouse),//#39
                () -> testPostApi(newDoctor, doctorDrHouse, 400, "Should not add new doctor with the same name"),
                () -> getAllDoctorslist(),//#41
                () -> testPostSetAppointments(leaWongApp1),//#42
                () -> testPostSetAppointments(leaWongApp2),//#43
                () -> testPostSetAppointments(leaWongApp3),//#44

                this::reloadServer,
                () -> testGetAllappointments(),//#45

                () -> testAvailableDatesByDoctor(leaWong, availableDays, 200),//#46
                () -> testAvailableDatesByDoctor(pamelaUpperson, availableDays, 200),//#47
                () -> testPostSetAppointments(pamelaUppersonApp1),//#48
                () -> testPostSetAppointments(pamelaUppersonApp2),//#49
                () -> testPostSetAppointments(pamelaUppersonApp3),//#50

                () -> testAvailableDatesByDoctor(doctorHouse, availableDays, 200),//#51
                () -> testPostSetAppointments(leaWongApp4),//#52
                () -> testPostSetAppointments(pamelaUppersonApp4),//#53

                () -> testGetAllappointments(),//#54

                () -> testGetStatisticPerDay(statisticsDay), //#55
                () -> testGetStatisticPerDoctor(statisticsDoctor),//#56

                () -> testDeleteAppointment(),//#57
                () -> testGetApi(appointments, 204, "Wrong Status code"),//#58

                () -> testDeleteAppointment(),//#59
                () -> testDeleteAppointmentApi(400, "Wrong Status code"),//#60

                () -> testAvailableDatesByDoctor(leaWong, availableDays, 200),//#61
                () -> testAvailableDatesByDoctor(pamelaUpperson, availableDays, 200),//#62

    //            () -> testGetStatisticPerDay(statisticsDay), //#68

                () -> testPostSetAppointments(pamelaUppersonApp1),//#63
                () -> testPostSetAppointments(pamelaUppersonApp2),//#64
                () -> testPostSetAppointments(pamelaUppersonApp3),//#65

                () -> testGetStatisticPerDay(statisticsDay), //#66

                () -> testDeleteDoctor(deleteDoctor, pamelaUpperson, 200, "should delete doctor"),//#67
                () -> testGetAllappointments(),//#70

                () -> testPostSetAppointments(leaWongApp1),//#71
                () -> testAvailableDatesByDoctor(leaWong, availableDays, 200),//#72
                () -> testGetStatisticPerDay(statisticsDay), //#73

                () -> testAvailableDatesByDoctor("director", availableDays, 200), //#74
                () -> testAvailableDatesByDoctor(pamelaUpperson, availableDays, 204),//#75

                () -> testGetStatisticPerDoctor(statisticsDoctor),//#76

                () -> testPostApi(setAppointment, directorApp1, 400, "not allowed to set appointment for director"),
                () -> testPostApi(newDoctor, docDirector, 400, "Should not add new doctor with the same name"),

                () -> testDeleteDoctor(deleteDoctor, leaWong, 200, "should delete doctor"),
                () -> testPostSetAppointments(drHouse),

                () -> testAvailableDatesByDoctor(doctorHouse, availableDays, 200),//#79
                () -> testGetAllappointments(),//#80

                () -> testGetStatisticPerDay(statisticsDay), //#81
                () -> testGetStatisticPerDoctor(statisticsDoctor),//#82

                () -> testDeleteDoctor(deleteDoctor, director, 200, "should delete  director"),//#83
                () -> testGetAllappointments(),//#84
                () -> testAvailableDatesByDoctor(director, availableDays, 204),//#85

                () -> testGetStatisticPerDoctor(statisticsDoctor),//#86
                () -> testGetStatisticPerDay(statisticsDay),//#87

                () -> newDoctorEndpointCheck(docDirector),//#88
                () -> testAvailableDatesByDoctor(director, availableDays, 200),//#89

                () -> testDeleteDoctor(deleteDoctor, doctorHouse, 200, "should delete  doctor"),//#90
                () -> testDeleteDoctor(deleteDoctor, director, 200, "should delete  director"),//#91
                () -> testDeleteDoctor(deleteDoctor, director, 400, "should delete  director"),//#92

                () -> testGetApi(appointments, 204, "Wrong Status code"),//#92
                () -> testGetApi(statisticsDoctor, 204, "Wrong Status code"),//#93
                () -> testGetApi(statisticsDay, 204, "Wrong Status code")//#94


        };

        //Test newDoctor POST endPoint
        CheckResult newDoctorEndpointCheck(String docName) {
            HttpResponse response = post("/newDoctor", docName).send();
            if (response.getStatusCode() != 200) {
                return CheckResult.wrong("/newDoctor should respond with " +
                        "status code 200, responded: " + response.getStatusCode() + "\n\n" +
                        "Response body:\n" + response.getContent());
            }
            JsonElement json;
            try {
                json = response.getJson();
            } catch (Exception ex) {
                return CheckResult.wrong("POST /newDoctor should return a valid JSON");
            }

            JsonObject responseJson = getJson(docName).getAsJsonObject();
            String doctorName = responseJson.get("doctorName").getAsString().trim().toLowerCase();
            System.out.println(response.getContent());
            expect(String.valueOf(json)).asJson().check(
                    isObject()
                            .value("id", isNumber())
                            .value("doctorName", doctorName)
            );

            long id = getJson(response.getContent()).getAsJsonObject().get("id").getAsLong();
            if (doctorsIdList.contains(id)) {
                return CheckResult.wrong("id should be unique. This id " + id + " exist");
            }
            doctorsList.add(response.getContent());
            doctorsIdList.add(id);

            return CheckResult.correct();
        }


        //Test AllDoctorslist GET endPoint
        CheckResult getAllDoctorslist() {
            HttpResponse response = get("/allDoctorslist").send();

            if (response.getStatusCode() != 200) {
                return CheckResult.wrong("GET /allDoctorslist should respond with " +
                        "status code 200, responded: " + response.getStatusCode() + "\n\n" +
                        "Response body:\n" + response.getContent());
            }

            JsonElement json;
            try {
                json = response.getJson();
            } catch (Exception ex) {
                return CheckResult.wrong("GET /allDoctorslist should return a valid JSON");
            }

            if (!response.getJson().isJsonArray()) {
                return CheckResult.wrong("Wrong object in response, expected array of JSON but was \n" +
                        response.getContent().getClass());
            }

            System.out.println(response.getContent());
            System.out.println(doctorsList.toString());

            String correctJsonToString = convert(doctorsList.toArray(new String[doctorsList.size()]));
            JsonArray correctJson = getJson(correctJsonToString).getAsJsonArray();
            JsonArray responseJson = getJson(response.getContent()).getAsJsonArray();

            if (responseJson.size() != correctJson.size()) {
                return CheckResult.wrong("Correct json array size should be" +
                        correctJson.size() + "\n\n" +
                        "Response array size is:\n" + responseJson.size());
            }

            for (int i = 0; i < responseJson.size(); i++) {
                long id = correctJson.get(i).getAsJsonObject().get("id").getAsLong();
    //            System.out.println(id);

                expect(responseJson.get(i).getAsJsonObject().toString()).asJson()
                        .check(isObject()
                                .value("id", id)
                                .value("doctorName", correctJson.get(i).getAsJsonObject().get("doctorName").getAsString()));


            }
            return CheckResult.correct();
        }

        //Test availableDatesByDoctor GET endPoint
        CheckResult testAvailableDatesByDoctor(String doctorName, int avalableDays, int status) {
            HttpResponse response = get("/availableDatesByDoctor?doc=" + doctorName.replaceAll("[\\s]+", "%20")).send();

            if (response.getStatusCode() != status) {
                return CheckResult.wrong("GET /availableDatesByDoctor?doc= " + doctorName + " should respond with " +
                        "status code " + status + " , responded: " + response.getStatusCode() + "\n\n" +
                        "Response body:\n" + response.getContent());
            }

            JsonElement json;
            if (status == 200) {
                try {
                    json = response.getJson();
                } catch (Exception ex) {
                    return CheckResult.wrong("GET /availableDatesByDoctor?doc= " + doctorName + " should return a valid JSON");
                }

                if (!response.getJson().isJsonArray()) {
                    return CheckResult.wrong("Wrong object in response, expected array of JSON but was \n" +
                            response.getContent().getClass());
                }


                System.out.println(response.getContent());


                JsonArray responseJson = getJson(response.getContent()).getAsJsonArray();

                if (doctorsList.stream().filter(s -> s.contains(doctorName.trim().toLowerCase())).findAny().isPresent()) {


                    if (responseJson.size() != avalableDays) {
                        return CheckResult.wrong("Correct json array size should be" +
                                avalableDays + "\n" +
                                "Response array size is:\n" + responseJson.size());
                    }

                    //
                    Gson gson = new Gson();
                    Type type = new TypeToken<List<Map<String, String>>>() {
                    }.getType();
                    List<Map<String, String>> myMap = gson.fromJson(responseJson, type);



                    for (int i = 0; i < myMap.size(); i++) {
                        if(myMap.get(i).size()!=2){ return CheckResult.wrong("Wrong. " +
                                "Response should contain 2 names in each JSON object\n");}

                        for (Map.Entry<String, String> entry : myMap.get(i).entrySet()) {
                            int countB = 0;
                            int countA = 0;

                            if (!entry.getKey().equals("booked")) {
                                countA++;
                                System.out.println(entry.getKey());
                                if (!entry.getKey().equals("availabletime")) {
                                    return CheckResult.wrong("Wrong name in JSON object \n"
                                            + "Expected response: " + "availabletime, " + " responded: " + entry.getKey());
                                }
                                if (countA > 1) {
                                    return CheckResult.wrong("Wrong name in JSON object \n"
                                            + "Expected response: " + "booked, " + " responded: " + entry.getKey());
                                }

                            }

                            if (!entry.getKey().equals("availabletime")) {

                                countB++;
                                System.out.println(entry.getKey());

                                if (!entry.getKey().equals("booked")) {
                                    return CheckResult.wrong("Wrong name in JSON object \n"
                                            + "Expected response: " + "booked, " + " responded: " + entry.getKey());
                                }
                                if (countB > 1) {
                                    return CheckResult.wrong("Wrong name in JSON object \n"
                                            + "Expected response: " + "availabletime, " + " responded: " + entry.getKey());
                                }

                            }

                        }

                    }
                    //
                    if (mapOfAvailableDaysByDoctor.isEmpty() || mapOfAvailableDaysByDoctor.get(doctorName.trim().toLowerCase()) == null) {

                        mapOfAvailableDaysByDoctor.put(doctorName.trim().toLowerCase(), responseJson);
                    }

                    if (!mapOfAvailableDaysByDoctor.isEmpty() && !mapOfAvailableDaysByDoctor.get(doctorName.trim().toLowerCase()).equals(responseJson)) {
                        return CheckResult.wrong("Wrong object in response, expected array of JSON " + mapOfAvailableDaysByDoctor.get(doctorName.trim().toLowerCase()).toString() +
                                "but it was" + response.getContent());
                    }
                    if (!mapOfAvailableDaysByDoctor.isEmpty() && mapOfAvailableDaysByDoctor.get(doctorName.trim().toLowerCase()).equals(responseJson)) {
                        JsonArray correctJson = mapOfAvailableDaysByDoctor.get(doctorName.trim().toLowerCase());

                        for (int i = 0; i < responseJson.size(); i++) {
                            String date = correctJson.get(i).getAsJsonObject().get("availabletime").getAsString();
                            boolean booked = correctJson.get(i).getAsJsonObject().get("booked").getAsBoolean();
    //            System.out.println(id);

                            expect(responseJson.get(i).getAsJsonObject().toString()).asJson()
                                    .check(isObject()
                                            .value("availabletime", date)
                                            .value("booked", booked));
                        }


                    }
                } else if (!doctorsList.stream().filter(s -> s.contains(doctorName.trim().toLowerCase())).findAny().isPresent()) {
                    if (responseJson.size() != 0) {
                        return CheckResult.wrong("Correct json array size should be 0 " +
                                "\n" +
                                "Response array size is:\n" + responseJson.size());
                    }
                }

                System.out.println(mapOfAvailableDaysByDoctor.entrySet());
                System.out.println(doctorsList.toString());
            }

            return CheckResult.correct();
        }


        // Test Post setAppointment
        CheckResult testPostSetAppointments(String appBody) {
            HttpResponse response = post("/setAppointment", appBody).send();

            if (response.getStatusCode() != 200) {
                return CheckResult.wrong("POST /setAppointment should respond with " +
                        "status code 200, responded: " + response.getStatusCode() + "\n\n" +
                        "Response body:\n" + response.getContent());
            }

            JsonElement json;
            try {
                json = response.getJson();
            } catch (Exception ex) {
                return CheckResult.wrong("POST /setAppointment should return a valid JSON");
            }

            JsonObject userJson = getJson(appBody).getAsJsonObject();
            String patient = userJson.get("patient").getAsString().trim().toLowerCase();
            String doctor = userJson.get("doctor").getAsString().toLowerCase().trim();
            String date = userJson.get("date").getAsString().toLowerCase().trim();
            System.out.println(date + "   " + doctor + " " + patient);

            expect(String.valueOf(json)).asJson().check(

                    isObject()
                            .value("idApp", isNumber())
                            .value("doctor", doctor)
    //                        .value("specialization", "physician")
    //                        .value("doctorId", isNumber())
                            .value("patient", patient)
                            .value("date", date)

            );


            long id = getJson(response.getContent()).getAsJsonObject().get("idApp").getAsLong();
            if (idsForAppointments.contains(id)) {
                return CheckResult.wrong("id should be unique. This id " + id + " exist");
            }
            appointmentsCorrectJson.add(response.getContent());
            idsForAppointments.add(id);

            if (statisticsPerDoctor != null && statisticsPerDoctor.containsKey(doctor)) {
                statisticsPerDoctor.put(doctor, statisticsPerDoctor.get(doctor) + 1);
            }
            if (statisticsPerDay != null && statisticsPerDay.containsKey(date)) {
                statisticsPerDay.put(date, statisticsPerDay.get(date) + 1);
            }

            if (statisticsPerDoctor != null && !statisticsPerDoctor.containsKey(doctor)) {
                statisticsPerDoctor.put(doctor, 1);
            }
            if (statisticsPerDay != null && !statisticsPerDay.containsKey(date)) {
                statisticsPerDay.put(date, 1);
            }
            if (statisticsPerDoctor == null || !statisticsPerDoctor.containsKey(doctor)) {
                statisticsPerDoctor = new TreeMap<>();
                statisticsPerDoctor.put(doctor, 1);
            }
            if (statisticsPerDay == null || !statisticsPerDay.containsKey(date)) {
                statisticsPerDay = new TreeMap<>();
                statisticsPerDay.put(date, 1);
            }

            for (Map.Entry<String, JsonArray> entry : mapOfAvailableDaysByDoctor.entrySet()
            ) {
                if (entry.getKey().equals(doctor)) {
                    for (int i = 0; i < entry.getValue().size(); i++) {
                        String avalabletime = entry.getValue().get(i).getAsJsonObject().get("availabletime").toString().replaceAll("\"", "");
                        if (avalabletime.equals(date)) {

                            entry.getValue().get(i).getAsJsonObject().addProperty("availabletime", avalabletime);
                            entry.getValue().get(i).getAsJsonObject().addProperty("booked", true);
                            System.out.println(entry.getValue().get(i).getAsJsonObject().get("booked"));
                            System.out.println(entry.getValue().get(i).getAsJsonObject().get("availabletime"));
                        }
                    }
                }
            }
            System.out.println(mapOfAvailableDaysByDoctor.entrySet());
            return CheckResult.correct();
        }

        CheckResult testGetAllappointments() {

            HttpResponse response = get("/appointments").send();

            if (response.getStatusCode() != 200) {
                return CheckResult.wrong("GET /appointments should respond with " +
                        "status code 200, responded: " + response.getStatusCode() + "\n\n" +
                        "Response body:\n" + response.getContent());
            }

            JsonElement json;
            try {
                json = response.getJson();
            } catch (Exception ex) {
                return CheckResult.wrong("GET /appointments should return a valid JSON");
            }

            if (!response.getJson().isJsonArray()) {
                return CheckResult.wrong("Wrong object in response, expected array of JSON but was \n" +
                        response.getContent().getClass());
            }

            System.out.println(response.getContent());
            System.out.println(appointmentsCorrectJson.toString());

            String correctJsonToString = convert(appointmentsCorrectJson.toArray(new String[appointmentsCorrectJson.size()]));
            JsonArray correctJson = getJson(correctJsonToString).getAsJsonArray();
            JsonArray responseJson = getJson(response.getContent()).getAsJsonArray();


            if (responseJson.size() != correctJson.size()) {
                return CheckResult.wrong("Correct json array size should be " +
                        correctJson.size() + "\n" +
                        "Response array size is: " + responseJson.size() + "\n");
            }


            for (int i = 0; i < responseJson.size(); i++) {


                expect(responseJson.get(i).getAsJsonObject().toString()).asJson()
                        .check(isObject()
                                .value("idApp", correctJson.get(i).getAsJsonObject().get("idApp").getAsLong())
                                .value("doctor", correctJson.get(i).getAsJsonObject().get("doctor").getAsString())
    //                            .value("specialization", correctJson.get(i).getAsJsonObject().get("specialization").getAsString())
    //                            .value("doctorId", correctJson.get(i).getAsJsonObject().get("doctorId").getAsLong())
                                .value("patient", correctJson.get(i).getAsJsonObject().get("patient").getAsString())
                                .value("date", correctJson.get(i).getAsJsonObject().get("date").getAsString()));
    //            ids.add(correctJson.get(i).getAsJsonObject().get("idApp").getAsLong());

            }

            return CheckResult.correct();
        }


        CheckResult testDeleteDoctor(String api, String param, int status, String message) {

            HttpResponse response = delete(api + param.trim().replaceAll("[\\s]+", "%20")).send();

            if (response.getStatusCode() != status) {
                return CheckResult.wrong("DELETE " + api + " should respond with "
                        + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                        + message + "\n"
                        + "Response body:\n" + response.getContent() + "\n"
                        + "Parameter:\n" + param);
            }
            if (response.getStatusCode() == 400 && !response.getContent().contains("Doctor not found")) {
                return CheckResult.wrong("Expected  response : \"Doctor not found\" but received " +
                        response.getContent());
            }

            if (status == 200) {
                JsonElement json;
                try {
                    json = response.getJson();
                } catch (Exception ex) {
                    return CheckResult.wrong("DELETE " + api + param + "should return a valid JSON");
                }
                if (doctorsList.isEmpty()) {
                    return CheckResult.correct();
                }
                String correctJsonToString = convert(doctorsList.toArray(new String[doctorsList.size()]));
                JsonArray correctJson = getJson(correctJsonToString).getAsJsonArray();
                String correctnameToBedeleted = "";
                Long correctId = -1L;

    //            for statisticPerDay


                for (int i = 0; i < correctJson.size(); i++) {
                    if (correctJson.get(i).getAsJsonObject().get("doctorName").getAsString().equals(param.trim().toLowerCase())) {

                        correctnameToBedeleted = correctJson.get(i).getAsJsonObject().get("doctorName").getAsString();
                        correctId = correctJson.get(i).getAsJsonObject().get("id").getAsLong();

                    }
                }

                expect(String.valueOf(json)).asJson().check(

                        isObject()
                                .value("id", correctId)
                                .value("doctorName", correctnameToBedeleted)

                );

                final String forFilter = correctnameToBedeleted;
                doctorsList = doctorsList.stream().filter(s -> !s.contains(forFilter)).collect(Collectors.toList());
                Optional<String> director1 = doctorsList.stream().filter(s -> s.contains("director")).findAny();
                if (!director1.isPresent()) {
                    String director = new RequestForTest().setProps("id", 10000).setProps("doctorName", "director").toJson();
                    doctorsList.add(director);
                }
                String keyToRemove = "";
                for (Map.Entry<String, JsonArray> entry : mapOfAvailableDaysByDoctor.entrySet()) {
                    if (entry.getKey().equals(forFilter)) {

                        keyToRemove = entry.getKey();
                    }
                }
                mapOfAvailableDaysByDoctor.remove(keyToRemove);
                Integer doctorAppointmentsCount = 0;
                Integer directorAppoinementsCount = 0;
                String key = "";
                for (Map.Entry<String, Integer> entry : statisticsPerDoctor.entrySet()) {
                    if (entry.getKey().equals(forFilter)) {
                        key = entry.getKey();
                        doctorAppointmentsCount = entry.getValue();
                        statisticsPerDoctor.remove(entry.getKey());
                        break;
                    }
                    if (entry.getKey().equals("director") && !forFilter.equals("director")) {

                        directorAppoinementsCount = entry.getValue();

                    }

                }
                if (!statisticsPerDoctor.isEmpty() && !key.equals("") && !forFilter.equals("director")) {
                    statisticsPerDoctor.put("director", doctorAppointmentsCount + directorAppoinementsCount);
                }

                String correctAppJsonToString = convert(appointmentsCorrectJson.toArray(new String[appointmentsCorrectJson.size()]));
                JsonArray correctAppJson = getJson(correctAppJsonToString).getAsJsonArray();

                if (forFilter.equals("director")) {
                    List<String> listOfDoctorDates = new ArrayList<>();

                    for (int i = 0; i < correctAppJson.size(); i++) {
                        if (correctAppJson.get(i).getAsJsonObject().get("doctor").getAsString().equals(param.trim().toLowerCase())) {
                            listOfDoctorDates.add(correctAppJson.get(i).getAsJsonObject().get("date").getAsString());
                        }
                    }
                    if (statisticsPerDay != null) {
                        int i = 0;
                        for (Map.Entry<String, Integer> entry : statisticsPerDay.entrySet()) {

                            if (listOfDoctorDates.get(i).equals(entry.getKey())) {
                                statisticsPerDay.put(entry.getKey(), entry.getValue() - 1);
                                i++;
                            }
                        }
                    }
                }

                List<String> intermediate = new ArrayList<>();
                for (int j = 0; j < appointmentsCorrectJson.size(); j++) {
                    if (appointmentsCorrectJson.get(j).contains(forFilter) && !forFilter.equals(director)) {
                        intermediate.add(appointmentsCorrectJson.get(j).replace(forFilter, "director"));
                    }

                    if (!appointmentsCorrectJson.get(j).contains(forFilter) && forFilter.equals(director)) {
                        intermediate.add(appointmentsCorrectJson.get(j));
                    }

                    if (appointmentsCorrectJson.get(j).contains(director) && !forFilter.equals(director)) {
                        intermediate.add(appointmentsCorrectJson.get(j));
                    }

                }
                appointmentsCorrectJson = intermediate;
            }
            return CheckResult.correct();
        }


        CheckResult testGetStatisticPerDay(String api) {

            HttpResponse response = get(api).send();

            if (response.getStatusCode() != 200) {
                return CheckResult.wrong("GET " + api + " should respond with " +
                        "status code 200, responded: " + response.getStatusCode() + "\n\n" +
                        "Response body:\n" + response.getContent());
            }

            JsonElement json;
            try {
                json = response.getJson();
            } catch (Exception ex) {
                return CheckResult.wrong("GET " + api + " should return a valid JSON");
            }

            if (!response.getJson().isJsonArray()) {
                return CheckResult.wrong("Wrong object in response, expected array of JSON but was \n" +
                        response.getContent().getClass());
            }


            JsonArray responseJson = getJson(response.getContent()).getAsJsonArray();

            Gson gson = new Gson();
            Type listType = new TypeToken<List<TreeMap<String, Integer>>>() {
            }.getType();
            List<TreeMap<String, Integer>> listOfCountsPreday =
                    gson.fromJson(responseJson, listType);
            Map<String, Integer> result = new TreeMap<>();

            for (int i = 0; i < listOfCountsPreday.size(); i++) {

                Map<String, Integer> collect = listOfCountsPreday.get(i)
                        .entrySet().stream()
                        .collect(Collectors
                                .toMap(Map.Entry::getKey, Map.Entry::getValue));
                collect.forEach((k, v) -> result.putIfAbsent(k, v));
            }


            System.out.println(listOfCountsPreday.toString());
            System.out.println(result);

            System.out.println(statisticsPerDay);
            if (!result.entrySet().stream()
                    .allMatch(e -> e.getValue().equals(statisticsPerDay.get(e.getKey())))) {
                return CheckResult.wrong("incorrect statistics");

            }

            return CheckResult.correct();
        }


        CheckResult testGetStatisticPerDoctor(String api) {

            HttpResponse response = get(api).send();

            if (response.getStatusCode() != 200) {
                return CheckResult.wrong("GET " + api + " should respond with " +
                        "status code 200, responded: " + response.getStatusCode() + "\n\n" +
                        "Response body:\n" + response.getContent());
            }

            JsonElement json;
            try {
                json = response.getJson();
            } catch (Exception ex) {
                return CheckResult.wrong("GET " + api + " should return a valid JSON");
            }
            if (!response.getJson().isJsonArray()) {
                return CheckResult.wrong("Wrong object in response, expected array of JSON but was \n" +
                        response.getContent().getClass());
            }

            JsonArray responseJson = getJson(response.getContent()).getAsJsonArray();

            Gson gson = new Gson();
            Type listType = new TypeToken<List<HashMap<String, Integer>>>() {
            }.getType();
            List<HashMap<String, Integer>> listOfCountsPerDoc =
                    gson.fromJson(responseJson, listType);
            Map<String, Integer> result = new TreeMap<>();

            for (int i = 0; i < listOfCountsPerDoc.size(); i++) {

                Map<String, Integer> collect = listOfCountsPerDoc.get(i)
                        .entrySet().stream()
                        .collect(Collectors
                                .toMap(Map.Entry::getKey, Map.Entry::getValue));
                collect.forEach((k, v) -> result.putIfAbsent(k, v));
            }


            System.out.println(listOfCountsPerDoc.toString());
            System.out.println(result);
            System.out.println(statisticsPerDoctor);
            if (!result.entrySet().stream()
                    .allMatch(e -> e.getValue().equals(statisticsPerDoctor.get(e.getKey())))) {
                return CheckResult.wrong("incorrect statistics");

            }

            return CheckResult.correct();
        }


        CheckResult testDeleteAppointment() {
            int size = idsForAppointments.size();
            for (int i = 0; i < size; i++) {


                HttpResponse response = delete("deleteAppointment?id=" + idsForAppointments.get(i)).send();


                if (response.getStatusCode() == 409 && response.getContent().contains("The appointment does not exist or one of the fields is null!")) {
                    System.out.println(response.getContent());
                    return CheckResult.correct();
                } else if (response.getStatusCode() == 400 && response.getContent().contains("The appointment does not exist or was already cancelled")) {
                    System.out.println(response.getContent());
                    return CheckResult.correct();
                } else if (response.getStatusCode() == 500 && response.getContent().contains("The date field is null!")) {
                    System.out.println(response.getContent());
                    return CheckResult.correct();
                }

                if (response.getStatusCode() != 200) {
                    return CheckResult.wrong("DELETE /deleteAppointment?id= should respond with " +
                            "status code 200, responded: " + response.getStatusCode() + "\n\n" +
                            "Response body:\n" + response.getContent());
                }

                JsonElement json;
                try {
                    json = response.getJson();
                } catch (Exception ex) {
                    return CheckResult.wrong("DELETE /deleteAppointment?id= should return a valid JSON");
                }

    //            if (!response.getJson().isJsonArray()) {
    //                return CheckResult.wrong("Wrong object in response, expected array of JSON but was \n" +
    //                        response.getContent().getClass());
    //            }

                String correctJsonToString = convert(appointmentsCorrectJson.toArray(new String[appointmentsCorrectJson.size()]));
                JsonArray correctJson = getJson(correctJsonToString).getAsJsonArray();
                JsonObject responseJson = getJson(response.getContent()).getAsJsonObject();

                expect(responseJson.toString()).asJson()
                        .check(isObject()
                                .value("idApp", correctJson.get(i).getAsJsonObject().get("idApp").getAsLong())
                                .value("doctor", correctJson.get(i).getAsJsonObject().get("doctor").getAsString())
    //                            .value("specialization", correctJson.get(i).getAsJsonObject().get("specialization").getAsString())
    //                            .value("doctorId", correctJson.get(i).getAsJsonObject().get("doctorId").getAsLong())
                                .value("patient", correctJson.get(i).getAsJsonObject().get("patient").getAsString())
                                .value("date", correctJson.get(i).getAsJsonObject().get("date").getAsString()));

                for (Map.Entry<String, JsonArray> entry : mapOfAvailableDaysByDoctor.entrySet()
                ) {
                    if (entry.getKey().equals(correctJson.get(i).getAsJsonObject().get("doctor").getAsString())) {
                        for (int m = 0; m < entry.getValue().size(); m++) {
                            String avalabletime = entry.getValue().get(m).getAsJsonObject().get("availabletime").toString().replaceAll("\"", "");
                            if (avalabletime.equals(correctJson.get(i).getAsJsonObject().get("date").getAsString())) {

                                entry.getValue().get(m).getAsJsonObject().addProperty("availabletime", avalabletime);
                                entry.getValue().get(m).getAsJsonObject().addProperty("booked", false);
                                System.out.println(entry.getValue().get(m).getAsJsonObject().get("booked"));
                                System.out.println(entry.getValue().get(m).getAsJsonObject().get("availabletime"));
                            }
                        }
                    }
                }
                for (Map.Entry<String, Integer> entry : statisticsPerDoctor.entrySet()) {
                    if (entry.getKey().equals(correctJson.get(i).getAsJsonObject().get("doctor").getAsString())) {
                        statisticsPerDoctor.put(entry.getKey(), entry.getValue() - 1);
                    }
                }
                String keyToRemove = "";
                for (Map.Entry<String, Integer> entry : statisticsPerDay.entrySet()) {
                    if (entry.getKey().equals(correctJson.get(i).getAsJsonObject().get("date").getAsString())) {
                        statisticsPerDay.put(entry.getKey(), entry.getValue() - 1);
                    }
                    if (entry.getValue() == 0) {
                        keyToRemove = entry.getKey();
                    }
                }
                statisticsPerDay.remove(keyToRemove);

                System.out.println(mapOfAvailableDaysByDoctor.entrySet());

            }

            for (int i = 0; i < size; i++) {

                appointmentsCorrectJson.remove(0);
                idsForAppointments.remove(0);
            }
            return CheckResult.correct();
        }

        CheckResult testDeleteAppointmentApi(int status, String message) {
            HttpResponse response = delete("deleteAppointment?id=" + 110).send();
            if (response.getStatusCode() != status) {
                return CheckResult.wrong("DELETE " + "deleteAppointment?id= 11" + " should respond with "
                        + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                        + message + "\n"
                        + "Response body:\n" + response.getContent() + "\n"
                );
            }

            if (response.getStatusCode() == 400 && !response.getContent().contains("The appointment does not exist or was already cancelled")) {
                return CheckResult.wrong("Expected  response : \"The appointment does not exist or was already cancelled\" but received " +
                        response.getContent());
            }


            return CheckResult.correct();
        }

        private CheckResult reloadServer() {
            try {
                reloadSpring();
            } catch (Exception ex) {
                throw new RuntimeException(ex.getMessage());
            }
            return CheckResult.correct();
        }
        @Before
        public  void deleteDatabaseFile() {
            File file = new File(databaseFileName);

            if (!file.exists()) {
                return;
            }

            if (!file.delete()) {
                throw new WrongAnswer("Can't delete database file before starting your program.\n" +
                        "Make sure you close all the connections with the database file!");
            }
        }
    }
  learner_created: false
- name: src/rest/available/Available.java
  visible: true
  text: |
    package rest.available;


    import lombok.AllArgsConstructor;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    import org.springframework.stereotype.Component;

    import javax.persistence.Entity;

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Component
    public class Available {

        private String availabletime;
        private boolean booked;

    }
  learner_created: true
- name: src/rest/available/AvailableController.java
  visible: true
  text: |
    package rest.available;


    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;
    import org.springframework.web.server.ResponseStatusException;
    import rest.appointment.Appointment;
    import rest.appointment.AppointmentService;
    import rest.doctor.DoctorService;

    import java.time.LocalDate;
    import java.util.ArrayList;
    import java.util.List;
    import java.util.Objects;
    import java.util.concurrent.atomic.AtomicBoolean;

    @RestController
    @RequestMapping
    public class AvailableController {
        @Autowired
        AppointmentService appointmentService;
        @Autowired
        DoctorService doctorService;
        @Autowired
        Available available;

        @GetMapping("/availableDatesByDoctor")
        public List<Available> getAvailableTime(@RequestParam String doc) {


            if (!doctorService.getAllDoctors().iterator().hasNext()) {
                throw new ResponseStatusException(HttpStatus.NO_CONTENT);
            }
            AtomicBoolean flag = new AtomicBoolean(false);
          doctorService.getAllDoctors().forEach(
                  doctor2 -> {
                      if (Objects.equals(doctor2.getDoctorName().toLowerCase(), doc.toLowerCase())) {
                          flag.set(true);
                      }
                  }
          );

          if (!flag.get()){
              throw new ResponseStatusException(HttpStatus.NO_CONTENT);
          }

            LocalDate lackDate;
            lackDate = LocalDate.parse("2022-11-03");
            List<Available> availableTime = new ArrayList<>();

                    for (int i = 0; i < 4; i++) {
                        String str  = lackDate.plusDays(i).toString();
                        available.setAvailabletime(str);
                        available.setBooked(true);
                        availableTime.add(available);
                    }



            return availableTime;

        }


    }
  learner_created: true
- name: src/rest/appointment/AppointmentController.java
  visible: true
  text: |
    package rest.appointment;

    import com.fasterxml.jackson.core.JsonProcessingException;
    import com.fasterxml.jackson.databind.ObjectMapper;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.validation.annotation.Validated;
    import org.springframework.web.bind.MethodArgumentNotValidException;
    import org.springframework.web.bind.annotation.*;
    import org.springframework.web.server.ResponseStatusException;

    import javax.transaction.Transactional;
    import javax.validation.Valid;
    import java.util.List;
    import java.util.Objects;

    @RestController
    @RequestMapping
    @Validated
    public class AppointmentController {


        @Autowired
        AppointmentService appointmentService;


        @ExceptionHandler(MethodArgumentNotValidException.class)
        @ResponseStatus(HttpStatus.BAD_REQUEST)
        public void handleValidationExceptions() {
            // Do nothing; the 400 status code is sufficient
        }

        @PostMapping("/setAppointment")
        public Appointment setAppointment(@RequestBody @Valid Appointment appointment) {
            if (Objects.equals(appointment.getDoctor(), "director")) {
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST);
            }
            appointmentService.saveAppointment(appointment);
            return appointmentService.getAppointment(appointment.getIdApp());
        }


        @DeleteMapping("/deleteAppointment")
        public ResponseEntity<String> deleteAppointment(@RequestParam Long id) throws JsonProcessingException {
            ObjectMapper objectMapper = new ObjectMapper();
            Appointment appointment = new Appointment();
            if (appointmentService.isHere(id)) {
                appointment = appointmentService.getAppointment(id);
                appointmentService.deleteAppointment(id);
                return ResponseEntity.ok(objectMapper.writeValueAsString(appointment));
            } else return ResponseEntity.badRequest().body("{\n" +
                    "   \"error\": \"The appointment does not exist or was already cancelled\"\n" +
                    "}");
        }

        @GetMapping("/appointments")
        public Iterable<Appointment> getAllAppointments() {
            if (!appointmentService.getAllAppointments().iterator().hasNext()) {
                throw new ResponseStatusException(HttpStatus.NO_CONTENT);
            }
            return appointmentService.getAllAppointments();
        }

    //    @PostMapping("/test")
    //    @Transactional
    //    public Iterable<Appointment> test(@RequestParam String name ) {
    //        appointmentService.modifyAll(name,"Mahmoud");
    //        return appointmentService.getAllAppointments();
    //    }


    }
  learner_created: true
- name: src/rest/doctor/DoctorRepo.java
  visible: true
  text: |
    package rest.doctor;

    import lombok.NonNull;
    import org.springframework.data.jpa.repository.Modifying;
    import org.springframework.data.jpa.repository.Query;
    import org.springframework.data.repository.CrudRepository;
    import org.springframework.data.repository.query.Param;
    import org.springframework.stereotype.Repository;

    import javax.transaction.Transactional;
    import javax.validation.constraints.NotBlank;
    import javax.validation.constraints.NotEmpty;
    import java.util.Optional;

    @Repository
    public interface DoctorRepo extends CrudRepository<Doctor, Long> {

        @Modifying
        @Query("UPDATE Doctor d SET d.doctorName = :newName WHERE d.doctorName = :oldName")
        void updateDoctorName(@Param("oldName") String oldName, @Param("newName") String newName);

        @Modifying
        @Query("DELETE FROM Doctor e WHERE e.doctorName = :name")
        @Transactional
        void deleteByName(@Param("name") String name);



        void deleteAllByDoctorName(String name);

        @Transactional
        boolean existsDoctorByDoctorName(String doctorName);

        @Query("SELECT d FROM Doctor d WHERE d.doctorName = :name")
        Optional<Doctor> findByDoctorName(@Param("name") String name);






    }
  learner_created: true
- name: src/rest/appointment/Appointment.java
  visible: true
  text: |+
    package rest.appointment;

    import lombok.*;
    import org.springframework.format.annotation.DateTimeFormat;
    import org.springframework.stereotype.Component;
    import javax.persistence.*;
    import javax.validation.constraints.*;


    @Data
    @Entity
    @AllArgsConstructor
    @NoArgsConstructor
    @Component
    public class Appointment {
        @Id
        @GeneratedValue
        private Long idApp;




        @NotEmpty
        @NotNull
        @NotBlank
        @Getter(AccessLevel.NONE)
        @Setter(AccessLevel.NONE)
        private String doctor= "";



        @NotEmpty
        @NotNull
        @NotBlank
        @Getter(AccessLevel.NONE)
        private String patient = "";


        @NotNull
        @NotBlank
        @NotNull
        @DateTimeFormat(iso = DateTimeFormat.ISO.DATE)
        @Pattern(regexp = "\\d{4}-\\d{2}-\\d{2}")
        private String date;

        public String getDoctor() {
            return doctor.toLowerCase();
        }

        public String getPatient() {
            return patient.toLowerCase();
        }
        public void setDoctor(String doctor) {
            this.doctor = doctor.toLowerCase();
        }

    }

  learner_created: true
- name: src/rest/doctor/Doctor.java
  visible: true
  text: |
    package rest.doctor;

    import lombok.*;
    import org.springframework.stereotype.Component;
    import rest.appointment.Appointment;

    import javax.persistence.*;
    import javax.validation.constraints.NotBlank;
    import javax.validation.constraints.NotEmpty;
    import java.util.List;

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    @Entity(name = "Doctor")
    @Component
    public class Doctor {

        @Id
        @GeneratedValue(strategy = GenerationType.AUTO)
        private Long id;

        @NonNull
        @NotBlank
        @NotEmpty
        @Getter(AccessLevel.NONE)
        private String doctorName="";



        public String getDoctorName() {
            return doctorName.toLowerCase();
        }


    }
  learner_created: true
- name: src/rest/appointment/AppointmentService.java
  visible: true
  text: |+
    package rest.appointment;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.stereotype.Service;
    import org.springframework.web.server.ResponseStatusException;

    import javax.transaction.Transactional;
    import java.util.List;

    @Service
    public class AppointmentService {
        @Autowired
        AppointmentRepo appointmentRepo;

        public void saveAppointment(Appointment appointment) {
            appointmentRepo.save(appointment);
        }

        public Appointment getAppointment(Long id) {
            return appointmentRepo.findById(id).orElseThrow(() -> new RuntimeException("Appointment not found with id " + id));
        }

        public void deleteAppointment(Long id) {
                appointmentRepo.deleteById(id);

        }

        public boolean isHere(Long id) {
            return appointmentRepo.existsById(id);
        }

        public Iterable<Appointment> getAllAppointments() {
            return appointmentRepo.findAll();
        }

        @Transactional
        public void modifyAll(String oldName, String  newName){
            appointmentRepo.updateDoctorName(oldName,newName);
        }



        @Transactional
        public void deleteAppointmentByName(String name){
            appointmentRepo.deleteByDoctor(name);
        }

        @Transactional
        void deleteAllByName(String name){
            appointmentRepo.deleteByDoctor(name);
        }
    }

  learner_created: true
- name: src/rest/doctor/DoctorService.java
  visible: true
  text: |+
    package rest.doctor;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.stereotype.Service;
    import org.springframework.web.server.ResponseStatusException;

    import javax.transaction.Transactional;
    import java.util.HashSet;
    import java.util.List;
    import java.util.Optional;
    import java.util.Set;

    @Service
    public class DoctorService {
        @Autowired
        DoctorRepo doctorRepo;

        @Transactional
        public void saveDoctor(Doctor doctor) {
            doctorRepo.findAll().forEach(doctor1 -> {
                if (doctor1.getDoctorName().equals(doctor.getDoctorName())) {
                    throw new ResponseStatusException(HttpStatus.BAD_REQUEST);
                }
            });
            doctorRepo.save(doctor);

        }

        public Doctor getDoctor(Long id) {
            return doctorRepo.findById(id).orElseThrow(() -> new ResponseStatusException(HttpStatus.BAD_REQUEST));
        }

        public Iterable<Doctor> getAllDoctors() {
            Iterable<Doctor> doctors = doctorRepo.findAll();
            if (!doctors.iterator().hasNext()) {
                throw new ResponseStatusException(HttpStatus.NO_CONTENT);
            }
            return doctors;
        }

        public boolean isDoctorExist(Long id) {
            return doctorRepo.existsById(id);
        }

        @Transactional
        void updateDoctor(String oldName, String newName) {
             doctorRepo.updateDoctorName(oldName, newName);
        }

        @Transactional
        void deleteDoctorByName(String name) {
            doctorRepo.deleteByName(name);
        }
        @Transactional
        void deleteAllByName(String name) {
            doctorRepo.deleteAllByDoctorName(name);
        }



        boolean isExistByName(String name) {
            return doctorRepo.existsDoctorByDoctorName(name);
        }

        public Long getDoctorIdByName(String name) {
            Optional<Doctor> optionalDoctor = doctorRepo.findByDoctorName(name);
            if (optionalDoctor.isPresent()) {
                Doctor doctor = optionalDoctor.get();
                return doctor.getId();
            } else {
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST
                        ,"Doctor not found");
            }
        }

        public Doctor getDoctorByName(String name) {

            return  doctorRepo.findByDoctorName(name).orElseThrow(
                    ()-> new ResponseStatusException(HttpStatus.BAD_REQUEST
                            ,"Doctor not found")
            );
        }

        @Transactional
        public void removeDuplicates() {
            List<Doctor> entities = (List<Doctor>) doctorRepo.findAll();
            Set<String> seenNames = new HashSet<>();

            for (Doctor entity : entities) {
                String name = entity.getDoctorName();
                if (seenNames.contains(name)) {
                    doctorRepo.delete(entity);
                } else {
                    seenNames.add(name);
                }
            }
        }
    }


  learner_created: true
- name: src/rest/doctor/DoctorController.java
  visible: true
  text: |
    package rest.doctor;

    import com.fasterxml.jackson.core.JsonProcessingException;
    import com.fasterxml.jackson.databind.ObjectMapper;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.validation.annotation.Validated;
    import org.springframework.web.bind.MethodArgumentNotValidException;
    import org.springframework.web.bind.annotation.*;
    import rest.appointment.AppointmentService;

    import javax.transaction.Transactional;
    import javax.validation.Valid;
    import java.util.logging.Logger;

    @RestController
    @RequestMapping
    @Validated
    public class DoctorController {

        Logger logger = Logger.getAnonymousLogger();
        @Autowired
        DoctorService doctorService;
        @Autowired
        AppointmentService appointmentService;

        @ExceptionHandler(MethodArgumentNotValidException.class)
        @ResponseStatus(HttpStatus.BAD_REQUEST)
        public void handleValidationExceptions() {
            // Do nothing; the 400 status code is sufficient
        }

        @PostMapping("/newDoctor")
        public Doctor addNewDoctor(@Valid @RequestBody Doctor doctor) {
            String name = doctor.getDoctorName().toLowerCase();
            doctor.setDoctorName(name.toLowerCase());
            doctorService.saveDoctor(doctor);
            return doctorService.getDoctor(doctor.getId());
        }

        @GetMapping("/allDoctorslist")
        public Iterable<Doctor> getAllDoctors() {
            logger.warning(doctorService.getAllDoctors().toString());
            doctorService.removeDuplicates();
            return doctorService.getAllDoctors();

        }

        @DeleteMapping("/deleteDoctor")
        @Transactional
        public ResponseEntity<String> deleteDoctor(@RequestParam String doc) throws JsonProcessingException {
            doctorService.removeDuplicates();
            ObjectMapper objectMapper = new ObjectMapper();
            logger.warning(doc);
            var docName = doc.toLowerCase();
            logger.warning(docName);
            if (!doctorService.isExistByName(docName))  {
                return new ResponseEntity<>("Doctor not found",HttpStatus.BAD_REQUEST);
            }

            Doctor doctor = doctorService.getDoctorByName(docName);
            if (docName.equals("director")) {
                doctorService.deleteAllByName(docName);
                appointmentService.deleteAppointmentByName(docName);
            } else {
                doctorService.updateDoctor(docName,"director");
                appointmentService.modifyAll(docName,"director");
                logger.warning(appointmentService.getAllAppointments().toString());

            }

            return ResponseEntity.ok(objectMapper.writeValueAsString(new Doctor(doctor.getId(),docName)));

        }


    }
  learner_created: true
- name: src/rest/appointment/AppointmentRepo.java
  visible: true
  text: |
    package rest.appointment;

    import org.springframework.data.jpa.repository.Modifying;
    import org.springframework.data.jpa.repository.Query;
    import org.springframework.data.repository.CrudRepository;
    import org.springframework.data.repository.query.Param;
    import org.springframework.stereotype.Repository;

    import javax.transaction.Transactional;
    import java.util.List;

    @Repository
    public interface AppointmentRepo extends CrudRepository<Appointment, Long> {


        @Transactional
        @Modifying
        @Query("UPDATE Appointment d SET d.doctor = :newName WHERE LOWER(d.doctor) = LOWER(:oldName)")
        void updateDoctorName(@Param("oldName") String oldName, @Param("newName") String newName);


        void deleteByDoctor(String name);
        @Transactional
        void deleteAllByDoctor(String name);

    }
  learner_created: true
- name: src/rest/statistics/Statistics.java
  visible: true
  learner_created: true
- name: src/rest/statistics/StatisticsController.java
  visible: true
  learner_created: true
- name: src/rest/config/SwaggerConfig.java
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/24011#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">Hyperskill</a>
    to continue learning.
  time: "Mon, 06 Mar 2023 01:49:20 UTC"
record: -1
